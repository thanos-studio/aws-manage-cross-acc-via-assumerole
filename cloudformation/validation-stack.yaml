AWSTemplateFormatVersion: '2010-09-09'
Description: Run a one-off validation Lambda that calls Sunrin's validation endpoint.

Parameters:
  OrganizationName:
    Type: String
    Description: Sunrin organisation name (no spaces)
    MinLength: 3
    MaxLength: 32
    AllowedPattern: '^[A-Za-z0-9-_]{3,32}$'
  ApiKey:
    Type: String
    Description: API key issued during organisation registration
    NoEcho: true
  SunrinNonce:
    Type: String
    Description: Unique nonce supplied by Sunrin to prevent replay
    Default: ""

Resources:
  ValidationFunctionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: SunrinFetchAccountMetadata
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - organizations:ListTagsForResource
                Resource: '*'

  ValidationFunction:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.12
      Handler: index.handler
      Role: !GetAtt ValidationFunctionRole.Arn
      Timeout: 30
      Environment:
        Variables:
          ORGANIZATION_NAME: !Ref OrganizationName
          API_ENDPOINT: 'http://eduardo-nonrousing-semicynically.ngrok-free.dev/api/integrations/validate'
          API_KEY: !Ref ApiKey
          SUNRIN_NONCE: !Ref SunrinNonce
      Code:
        ZipFile: |
          import json
          import os
          import time
          import uuid
          import hmac
          import hashlib
          import urllib.request
          import urllib.error
          import boto3
          from botocore.exceptions import BotoCoreError, ClientError

          def _fetch_account_metadata():
              """Collect AWS account metadata for validation telemetry."""
              sts = boto3.client("sts")
              identity = sts.get_caller_identity()
              account_id = identity.get("Account")
              arn = identity.get("Arn", "")
              partition = "aws"
              if arn and ":" in arn:
                  try:
                      partition = arn.split(":")[1]
                  except IndexError:
                      partition = "aws"

              tags = {}
              try:
                  orgs = boto3.client("organizations")
                  paginator = orgs.get_paginator("list_tags_for_resource")
                  for page in paginator.paginate(ResourceId=account_id):
                      for tag in page.get("Tags", []):
                          key = tag.get("Key")
                          value = tag.get("Value")
                          if key is not None and value is not None:
                              tags[key] = value
              except (ClientError, BotoCoreError, Exception) as err:  # broad catch for missing permissions
                  print("failed to fetch account tags:", err)

              return account_id, partition, tags

          def _respond(event, context, status, reason="", data=None):
              response_body = {
                  "Status": status,
                  "Reason": reason or f"See CloudWatch Logs for details: {context.log_stream_name}",
                  "PhysicalResourceId": context.log_stream_name,
                  "StackId": event["StackId"],
                  "RequestId": event["RequestId"],
                  "LogicalResourceId": event["LogicalResourceId"],
                  "Data": data or {},
              }
              body = json.dumps(response_body).encode()
              req = urllib.request.Request(
                  event["ResponseURL"],
                  data=body,
                  method="PUT",
                  headers={"Content-Type": "", "Content-Length": str(len(body))},
              )
              with urllib.request.urlopen(req, timeout=10):
                  pass

          def handler(event, context):
              request_type = event.get("RequestType", "Create")
              if request_type == "Delete":
                  _respond(event, context, "SUCCESS")
                  return

              try:
                  org = os.environ["ORGANIZATION_NAME"]
                  endpoint = os.environ["API_ENDPOINT"]
                  api_key = os.environ["API_KEY"]
                  hmac_key = api_key.encode()
                  nonce = os.environ.get("SUNRIN_NONCE") or uuid.uuid4().hex

                  account_id, partition, tags = _fetch_account_metadata()

                  timestamp = str(int(time.time()))
                  payload = json.dumps({
                      "org_name": org,
                      "api_key": api_key,
                      "account_id": account_id,
                      "account_partition": partition,
                      "account_tags": tags,
                  }).encode()

                  message = f"{timestamp}|{nonce}|".encode() + payload
                  signature = hmac.new(hmac_key, message, hashlib.sha256).hexdigest()

                  request = urllib.request.Request(
                      endpoint,
                      data=payload,
                      method="POST",
                      headers={
                          "Content-Type": "application/json",
                          "X-Sig-Signature": signature,
                          "X-Sig-Timestamp": timestamp,
                          "X-Sig-Nonce": nonce,
                      },
                  )

                  try:
                      with urllib.request.urlopen(request, timeout=10) as resp:
                          body = resp.read().decode()
                          print("validation success:", body)
                  except urllib.error.HTTPError as http_err:
                      error_body = http_err.read().decode()
                      print("validation error body:", error_body)
                      raise RuntimeError(f"validation request failed: {http_err.code} {error_body}") from http_err

                  _respond(
                      event,
                      context,
                      "SUCCESS",
                      data={
                          "ResponseBody": body,
                          "Timestamp": timestamp,
                          "Nonce": nonce,
                      },
                  )

              except Exception as exc:
                  _respond(event, context, "FAILED", reason=str(exc))

  ValidationFunctionInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref ValidationFunction
      Action: lambda:InvokeFunction
      Principal: cloudformation.amazonaws.com
      SourceArn: !Sub arn:aws:cloudformation:${AWS::Region}:${AWS::AccountId}:stack/*

  ValidationTrigger:
    Type: AWS::CloudFormation::CustomResource
    DependsOn:
      - ValidationFunctionInvokePermission
    Properties:
      ServiceToken: !GetAtt ValidationFunction.Arn

Outputs:
  ValidationFunctionArn:
    Description: ARN of the validation Lambda function
    Value: !GetAtt ValidationFunction.Arn
